(function(){"use strict";self.onmessage=async s=>{const{file1:u,file2:o,keyField:n,ignoredFields:e}=s.data;try{const c=new Set(e?e.split(",").map(t=>t.trim().toLowerCase()).filter(t=>t):[]);self.postMessage({type:"PROGRESS",message:"Reading and parsing files..."});const d=await u.text(),f=await o.text();let a=JSON.parse(d),i=JSON.parse(f);const S=t=>{if(Array.isArray(t))return t;if(t&&typeof t=="object"){let l=null;for(const g in t)Array.isArray(t[g])&&(!l||t[g].length>l.length)&&(l=t[g]);return l}return null},A=S(a),O=S(i);if(!A||!O)throw new Error("Could not find an array of items to compare. Ensure your JSON contains a list of objects.");self.postMessage({type:"PROGRESS",message:`Found ${A.length} items in source and ${O.length} in target. Processing exclusions...`});const T=A.map(t=>p(t,c,n)),v=O.map(t=>p(t,c,n)),r={modified:[],added:[],removed:[],unchanged:[],summary:{totalRecords:0,modifiedCount:0,addedCount:0,removedCount:0,unchangedCount:0}};self.postMessage({type:"PROGRESS",message:"Comparing records..."});const k=C(T,n),E=C(v,n),x=new Set([...Object.keys(k),...Object.keys(E)]);r.summary.totalRecords=x.size;for(const t of x){const l=k[t]||[],g=E[t]||[],G=Math.max(l.length,g.length);for(let h=0;h<G;h++){const y=l[h],m=g[h];if(y&&m){const M=R(y,m,"",c);M.length>0?r.modified.push({keyValue:t,source:y,target:m,differences:M}):r.unchanged.push(y)}else y?r.removed.push(y):m&&r.added.push(m)}}r.summary.modifiedCount=r.modified.length,r.summary.addedCount=r.added.length,r.summary.removedCount=r.removed.length,r.summary.unchangedCount=r.unchanged.length,r.summary.totalRecords=r.modified.length+r.added.length+r.removed.length+r.unchanged.length,self.postMessage({type:"COMPLETE",result:r})}catch(c){self.postMessage({type:"ERROR",error:c.message})}};function p(s,u,o){if(s===null||typeof s!="object")return s;if(Array.isArray(s))return s.map(e=>p(e,u,o));const n={};for(const e in s)(e===o||!u.has(e.toLowerCase()))&&(n[e]=p(s[e],u,o));return n}function C(s,u){return Array.isArray(s)?s.reduce((o,n)=>{const e=n[u]!==void 0?String(n[u]):"no-key";return o[e]||(o[e]=[]),o[e].push(n),o},{}):{}}function R(s,u,o,n){const e=[],c=new Set([...Object.keys(s),...Object.keys(u)]);for(const d of c){if(n.has(d.toLowerCase()))continue;const f=o?`${o}.${d}`:d,a=s[d],i=u[d];a!==void 0&&i===void 0?e.push({path:f,sourceValue:a,targetValue:null,changeType:"removed"}):a===void 0&&i!==void 0?e.push({path:f,sourceValue:null,targetValue:i,changeType:"added"}):a!==i&&(w(a)&&w(i)?e.push(...R(a,i,f,n)):Array.isArray(a)&&Array.isArray(i)?JSON.stringify(a)!==JSON.stringify(i)&&e.push({path:f,sourceValue:a,targetValue:i,changeType:"modified"}):a!==i&&e.push({path:f,sourceValue:a,targetValue:i,changeType:"modified"}))}return e}function w(s){return s&&typeof s=="object"&&!Array.isArray(s)}})();
